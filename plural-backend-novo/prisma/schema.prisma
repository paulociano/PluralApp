// Arquivo: prisma/schema.prisma
// Versão Final Corrigida e Verificada

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String             @id @default(cuid())
  email             String             @unique
  name              String
  password          String
  username          String             @unique
  bio               String?
  createdAt         DateTime           @default(now())
  points            Int                @default(0)
  role              Role               @default(USER)

  arguments         Argument[]
  votes             Vote[]
  notifications     Notification[]     @relation("Recipient")
  triggered         Notification[]     @relation("Trigger")
  reportsMade       Report[]           @relation("Reporter")
  favoriteArguments FavoriteArgument[]
  badges            UserBadge[]
  createdTopics     Topic[]            @relation("CreatedTopics")
}

model Topic {
  id          String         @id @default(cuid())
  title       String
  description String
  createdAt   DateTime       @default(now())
  category    TopicCategory?
  status      TopicStatus    @default(PENDING)

  // Relação correta para saber quem criou o tópico
  createdById String
  createdBy   User           @relation("CreatedTopics", fields: [createdById], references: [id])

  arguments   Argument[]
}

model Argument {
  id               String             @id @default(cuid())
  content          String
  referenceUrl     String?
  type             ArgType
  createdAt        DateTime           @default(now())
  votesCount       Int                @default(0)
  replyCount       Int                @default(0)
  
  authorId         String
  author           User               @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  topicId          String
  topic            Topic              @relation(fields: [topicId], references: [id], onDelete: Cascade)
  
  parentArgumentId String?
  parentArgument   Argument?          @relation("Replies", fields: [parentArgumentId], references: [id], onDelete: SetNull)
  
  replies          Argument[]         @relation("Replies")
  votes            Vote[]
  reports          Report[]           @relation("ReportedArgument")
  favoritedBy      FavoriteArgument[]
  originOfNotifications Notification[] @relation("OriginArgumentNotifications")
}

model Vote {
  id         String   @id @default(cuid())
  type       VoteType
  userId     String
  argumentId String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  argument   Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([userId, argumentId])
}

model FavoriteArgument {
  id         String   @id @default(cuid())
  userId     String
  argumentId String
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  argument Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)

  @@unique([userId, argumentId])
}

model Notification {
  id               String           @id @default(cuid())
  type             NotificationType
  isRead           Boolean          @default(false)
  createdAt        DateTime         @default(now())
  
  recipientId      String
  recipient        User             @relation("Recipient", fields: [recipientId], references: [id], onDelete: Cascade)
  
  triggerUserId    String
  triggerUser      User             @relation("Trigger", fields: [triggerUserId], references: [id], onDelete: Cascade)
  
  originArgumentId String
  originArgument   Argument         @relation("OriginArgumentNotifications", fields: [originArgumentId], references: [id], onDelete: Cascade)
}

model Report {
  id                 String       @id @default(cuid())
  reason             ReportReason
  notes              String?
  status             ReportStatus @default(PENDING)
  createdAt          DateTime     @default(now())
  
  reporterId         String
  reporter           User         @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  
  reportedArgumentId String
  reportedArgument   Argument     @relation("ReportedArgument", fields: [reportedArgumentId], references: [id], onDelete: Cascade)

  @@unique([reporterId, reportedArgumentId])
}

model Badge {
  id          String      @id @default(cuid())
  name        String      @unique
  description String
  icon        String
  createdAt   DateTime    @default(now())
  users       UserBadge[]
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  badgeId   String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
}

model Article {
  id             String   @id @default(cuid())
  title          String
  content        String   @db.Text
  authorName     String
  authorTitle    String?
  authorImageUrl String?
  published      Boolean  @default(false)
  createdAt      DateTime @default(now())
}

model FallacyType {
  id          String             @id @default(cuid())
  name        String             @unique
  description String             @db.Text
  exercises   TrainingExercise[]
}

model TrainingExercise {
  id               String      @id @default(cuid())
  text             String      @db.Text
  explanation      String      @db.Text
  
  correctFallacyId String
  correctFallacy   FallacyType @relation(fields: [correctFallacyId], references: [id])
}

enum TopicStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ArgType {
  PRO
  CONTRA
  NEUTRO
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

enum Role {
  USER
  ADMIN
}

enum NotificationType {
  NEW_REPLY
}

enum ReportReason {
  SPAM
  OFFENSIVE
  DISINFORMATION
  OTHER
}

enum ReportStatus {
  PENDING
  RESOLVED
  DISMISSED
}

enum TopicCategory {
  TECNOLOGIA
  SOCIEDADE
  CULTURA
  POLITICA
  MEIO_AMBIENTE
  CIENCIA
  OUTRO
}